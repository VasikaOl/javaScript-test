* * * Функція це приватний випадок обєкта -> ТИП ПОСИЛАННЯ

console.log('[] === []: ', [] === []);
console.log('{} === {}: ', {} === {});
console.log(
    'function() {} === function() {}: ',
    function() {} === function() {},
);

const fnA = function () {
    console.log('hello');
}
const fnB = fnA;
console.log('fnB === fnA: ', fnB === fnA);

* * Контекст (this)
  *  - Де і як була оголошена функція НЕ МАЄ НІЯКОГО ВПЛИВУ на контекст
  *  - Контекст визначається в МОМЕНТ ВИЗОВА ФУНКЦІЇ, якщо він не привязаний явно.

* * Як метод обєкта. В контексті обєкта.

const user = {
    tag: 'Mango',
    showTag() {
        console.log('showTag -> this', this);
    },
};
user.showTag();

* * Виклик без контекста
  *  - В строгому режимі = undefined
  *  - Не в строгому режимі = window

const foo = function () {
    console.log('foo -> this', this)
}
foo();

* * Як метод обєкта, але оголошена як зовнішня функція.
* * В контексті обєкта.

const showTag = function () {
    console.log('showTag -> this', this);
    console.log('showTag -> this.tag', this.tag);
};

// showTag();

const user = {
    tag: 'Mango',
};
user.showUserTag = showTag;
console.log('user', user);

user.showUserTag();

* * Виклик без контексту, але оголошена як метод обєкта

const user = {
    tag: 'Mango',
    showTag() {
        console.log('showTag -> this', this);
        console.log('showTag -> this.tag', this.tag);
    },
};
user.showTag();

const outerShowTag = user.showTag;

outerShowTag();

* * Контекст в call-back функціях



 